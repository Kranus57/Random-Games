<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chess vs Computer</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard.js/1.0.0/css/chessboard-1.0.0.min.css">
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      background: linear-gradient(135deg, #2c3e50, #34495e);
      color: white;
    }
    h1 {
      margin: 20px;
      color: #f1c40f;
      text-shadow: 1px 1px 5px black;
    }
    #board {
      width: 480px;
      margin: 20px auto;
      border: 4px solid #000;
      box-shadow: 0 0 20px rgba(0,0,0,0.6);
      border-radius: 8px;
    }
    #status {
      font-size: 18px;
      margin: 15px;
    }
    select, button {
      padding: 8px 15px;
      margin: 10px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-size: 14px;
    }
    select { background: #16a085; color: white; }
    button { background: #e67e22; color: white; }
    button:hover, select:hover { opacity: 0.9; }
  </style>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
<script src="{{ url_for('static', filename='script.js') }}"></script>
</head>
<body>
  <h1>♟️ Chess vs Computer</h1>
  <label>Difficulty:</label>
  <select id="aiLevel" onchange="resetGame()">
    <option value="1">Low</option>
    <option value="2">Medium</option>
    <option value="3">Hard</option>
    <option value="4">Very Hard</option>
  </select>
  <div id="board"></div>
  <p id="status">Your turn (White)</p>
  <button onclick="resetGame()">Restart</button>
  <a href="/">Back to Home</a>

  <!-- Chess libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard.js/1.0.0/js/chessboard-1.0.0.min.js"></script>

  <script>
    let board, game, aiLevel;

    function initGame() {
      game = new Chess();
      aiLevel = parseInt(document.getElementById("aiLevel").value);
      board = Chessboard('board', {
        draggable: true,
        position: 'start',
        onDrop: onDrop,
        pieceTheme: 'https://cdnjs.cloudflare.com/ajax/libs/chessboard.js/1.0.0/img/chesspieces/wikipedia/{piece}.png'
      });
      updateStatus();
    }

    function onDrop(source, target) {
      let move = game.move({ from: source, to: target, promotion: 'q' });
      if (move === null) return 'snapback';
      updateStatus();
      if (!game.game_over()) setTimeout(makeAIMove, 400);
    }

    function makeAIMove() {
      const possibleMoves = game.moves();
      if (possibleMoves.length === 0) return;

      let move;
      if (aiLevel === 1) move = randomMove();
      else if (aiLevel === 2) move = greedyMove();
      else if (aiLevel === 3) move = minimaxRoot(2, game, true).move;
      else move = minimaxRoot(3, game, true).move;

      game.move(move);
      board.position(game.fen());
      updateStatus();
    }

    function randomMove() {
      const moves = game.moves();
      return moves[Math.floor(Math.random() * moves.length)];
    }

    function greedyMove() {
      const moves = game.moves();
      let bestVal = -Infinity, bestMove = moves[0];
      moves.forEach(move => {
        game.move(move);
        let value = evaluateBoard(game.board());
        game.undo();
        if (value > bestVal) { bestVal = value; bestMove = move; }
      });
      return bestMove;
    }

    function minimaxRoot(depth, game, isMax) {
      const moves = game.moves();
      let bestMove = -Infinity, bestFound;
      moves.forEach(move => {
        game.move(move);
        let value = minimax(depth - 1, game, -Infinity, Infinity, !isMax);
        game.undo();
        if (value > bestMove) { bestMove = value; bestFound = move; }
      });
      return { move: bestFound, score: bestMove };
    }

    function minimax(depth, game, alpha, beta, isMax) {
      if (depth === 0) return -evaluateBoard(game.board());
      const moves = game.moves();
      if (isMax) {
        let best = -Infinity;
        for (let move of moves) {
          game.move(move);
          best = Math.max(best, minimax(depth - 1, game, alpha, beta, false));
          game.undo();
          alpha = Math.max(alpha, best);
          if (beta <= alpha) break;
        }
        return best;
      } else {
        let best = Infinity;
        for (let move of moves) {
          game.move(move);
          best = Math.min(best, minimax(depth - 1, game, alpha, beta, true));
          game.undo();
          beta = Math.min(beta, best);
          if (beta <= alpha) break;
        }
        return best;
      }
    }

    function evaluateBoard(board) {
      const values = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 1000 };
      let score = 0;
      board.flat().forEach(piece => {
        if (piece) score += piece.color === 'w' ? values[piece.type] : -values[piece.type];
      });
      return score;
    }

    function updateStatus() {
      let status = '';
      if (game.in_checkmate()) {
        status = 'Game Over, ' + (game.turn() === 'w' ? 'Black' : 'White') + ' wins!';
      } else if (game.in_draw()) {
        status = 'Draw!';
      } else {
        status = (game.turn() === 'w' ? 'White' : 'Black') + ' to move';
        if (game.in_check()) status += ' (Check!)';
      }
      document.getElementById("status").textContent = status;
    }

    function resetGame() { initGame(); }

    initGame();
  </script>
</body>
</html>
